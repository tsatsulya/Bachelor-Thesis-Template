\section{Обзор существующих решений}
\label{sec:Chapter2} \index{Chapter2}

\subsection*{Интеграция примитивных типов в высокоуровневую систему типов и их влияние на семантический анализ}

\subsection{Явное разделение с автоматическим преобразованием}

\begin{itemize}[label={--}]
    \item \textbf{Суть:} Примитивные типы (`int`, `float`, `boolean`) и объектные типы (`Integer`, `Float`, `Boolean`) существуют параллельно и явно различимы в системе типов языка. Компилятор автоматически вставляет преобразования (боксинг - примитив -> объектная обертка, анбоксинг - объектная обертка -> примитив) там, где контекст требует типа другого вида (например, передача `int` в метод, ожидающий `Object`, или использование `Integer` в арифметической операции).

    \item \textbf{Влияние на систему типов:}
    \begin{itemize}
        \item Явный дуализм типов
        \item Примитивы не являются частью объектной иерархии
        \item Необходимость учёта примитивных типов в правилах подтипирования
    \end{itemize}

    \item \textbf{Влияние на семантический анализ:}
    \textbf{Значительно усложняет анализ}
    \begin{itemize}[label={--}]
        \item Отслеживание контекстов, требующих преобразований
        \item Разрешать перегрузки методов с примитивными и объектными параметрами (иногда приводя к неочевидному выбору)
        \item Обрабатывать потенциальные \code{NullPointerException} при анбоксинге \code{null}
        \item Учитывать различия в семантике (например,  \code{==} для примитивов vs. для объектов)
        \item Иметь отдельные ветви кода для проверки типов примитивов и объектов
    \end{itemize}

    \item \textbf{Преимущества:}
    Позволяет использовать примитивы для производительности и объектные обертки там, где нужна полиморфность (коллекции). Понятна разработчикам низкого уровня.

    \item \textbf{Недостатки:} Сложная система типов и семантический анализ, риск ошибок `NullPointerException` из-за неявного анбоксинга, потенциальные накладные расходы на преобразования, концептуальный разрыв для разработчика.

    \item \textbf{Примеры:} Java (классический пример), ранние версии C\#
\end{itemize}

\newpage

\begin{lstlisting}[language=java,title=Пример в Java]
Integer x = 10;  // Автобоксинг
int y = x;       // Автоанбоксинг
if (y == x) {    // Сравнение с автоанбоксингом
    System.out.println("Equal");
}
\end{lstlisting}

\subsection{Единая Иерархия Типов с Значимыми Типами}

\begin{itemize}[leftmargin=*, label={--}]
    \item \textbf{Суть:} Примитивные типы реализованы как \textbf{значимые типы (value types)}, которые являются частью единой объектной иерархии типов (например, наследуются от базового класса \texttt{ValueType}, который сам наследуется от \texttt{Object}). Все типы (и ссылочные, и значимые) формально являются подтипами Object. Однако, между ссылочными (классы) и значимыми (структуры, примитивы) типами сохраняется фундаментальное различие в семантике: передача по ссылке и передача по значению (копированию), размещение в куче и в стеке/встроенно.

    \item \textbf{Влияние на систему типов:} Формально единая иерархия, но с глубоким внутренним разделением. Примитивы/значимые типы могут реализовывать интерфейсы. Возможно ограниченное наследование для значимых типов (или его отсутствие).

    \item \textbf{Влияние на cемантический aнализ:}
    \textbf{Усложнен.}
    Анализатор должен:
    \begin{itemize}
        \item Различать ссылочные и значимые типы на протяжении всего анализа.
        \item Учитывать семантику копирования при присваивании и передаче в методы для значимых типов.
        \item Обрабатывать боксинг/анбоксинг (упаковку/распаковку) при необходимости преобразования значимого типа в ссылочный (\code{object}, интерфейс) и обратно, со всеми вытекающими последствиями (накладные расходы, \texttt{Null}?).
        \item Учитывать различия в поведении операторов (например, \code{==} по умолчанию для значимых типов сравнивает значения, а для ссылочных - ссылки).
    \end{itemize}

    \item \textbf{Преимущества:} Более единообразная модель типов, чем в Java. Значимые типы позволяют создавать эффективные пользовательские структуры данных. Возможность полиморфизма через интерфейсы.

    \item \textbf{Недостатки:} Сохраняется концептуальная сложность разделения ref/value. Семантический анализ все еще должен обрабатывать два разных вида типов и преобразования между ними. Риск неочевидных накладных расходов на упаковку.

    \item \textbf{Примеры:} C\# (структуры \code{struct}, примитивы как псевдонимы для системных структур типа \code{System.Int32}), Swift (value semantics для структур и перечислений).
\end{itemize}


\subsection{Примитивы как оптимизация компилятора (Инлайнинг)}

\begin{itemize}[label={--}, leftmargin=*]
    \item \textbf{Суть:} Система типов языка оперирует только высокоуровневыми объектными типами. Примитивные типы абстрагированы на уровне семантики языка. Компилятор на поздних стадиях (после семантического анализа) агрессивно оптимизирует использование этих объектов:
    \begin{itemize}[label={--}]
        \item заменяет их на низкоуровневые примитивные значения,
        \item подставляет реализацию их методов напрямую в код,
        \item устраняет накладные расходы на вызовы методов и выделение памяти.
    \end{itemize}
    Примитив используется только как реализационная деталь оптимизации, невидимая для семантики языка.

    \item \textbf{Влияние на cистему типов:} \textbf{Единая объектная модель.} Примитивы представлены как специальные неизменяемые объектные типы (часто \code{final} классы или \code{inline} классы). Для системы типов и разработчика они:
    \begin{itemize}[label={--}]
        \item выглядят и ведут себя как обычные объекты,
        \item имеют методы,
        \item могут быть упакованы в общие интерфейсы.
    \end{itemize}

    \item \textbf{Влияние на семантический Анализ:} \textbf{Существенно упрощен.} Анализатор работает исключительно с объектными типами. Нет необходимости:
    \begin{itemize}[label={--}]
        \item Различать примитивы и объекты при проверке типов.
        \item Обрабатывать правила боксинга/анбоксинга (их нет на уровне семантики).
        \item Беспокоиться о \code{NullPointerException} для самих объектных аналогов примитивов.
    \end{itemize}

    \item \textbf{Преимущества:}
    \begin{itemize}[label={--}]
        \item Максимально простая и единообразная система типов,
        \item Упрощенный семантический анализ для высокоуровневых конструкций,
        \item Сохранение производительности примитивов через оптимизацию,
        \item Высокая абстракция для разработчика.
    \end{itemize}

    \item \textbf{Недостатки:}
    \begin{itemize}
        \item Сложность реализации оптимизирующего компилятора,
        \item Необходимость четких правил для компилятора (например, часто требуется \code{final}/неизменяемость),
        \item Возможные ограничения:
        \begin{itemize}
            \item массивы примитивных объектов могут быть менее эффективны,
            \item работа с рефлексией может показывать обертку.
        \end{itemize}
    \end{itemize}

    \item \textbf{Примеры:}
    \begin{itemize}
        \item Kotlin (\code{inline} классы для представления примитивоподобных типов),
        \item Scala (классы-значения \code{AnyVal} и их подклассы для \code{Int}, \code{Double} и т.д. - хотя в Scala есть и примитивы JVM, \code{AnyVal} абстрагирует их на уровне семантики Scala).
    \end{itemize}
\end{itemize}



\subsection{Полное Удаление Примитивных Типов}

\begin{itemize}[leftmargin=*, label={--}]
    \item \textbf{Суть:}
    \begin{itemize}
        \item В системе типов языка отсутствует само понятие "примитивный тип"
        \item Все данные (целые числа, числа с плавающей точкой, булевы значения, символы) являются полноценными объектами
        \item Операции над ними реализованы сключительно как методы этих объектов
        \item Любая низкоуровневая оптимизация(представление в виде примитивных значений процессора или inline-подстановка операций)
        является исключительной задачей компилятора или среды выполнения:
        \begin{itemize}
            \item Происходит после этапа семантического анализа
            \item Не влияет на правила языка и работу семантического анализатора
        \end{itemize}
    \end{itemize}

    \item \textbf{Влияние на Систему Типов:}
    \begin{itemize}
        \item \textbf{Абсолютно единая объектная иерархия}
        \item Все типы являются объектными
        \item Нет дуализма или разделения на ref/value на уровне абстракции языка
    \end{itemize}

    \item \textbf{Влияние на Семантический Анализ:}
    \begin{itemize}
        \item \textbf{Максимально упрощен и унифицирован}
        \item Анализатор:
        \begin{itemize}
            \item Работает только с объектными типами и их методами
            \item Проверяет типы и разрешает перегрузки методов по единым правилам
            \item Обрабатывает операции как обычные вызовы методов (\code{a.plus(b)}, \code{x.equals(y)})
            \item Не содержит никакого кода, специфичного для обработки примитивов
        \end{itemize}
    \end{itemize}

    \item \textbf{Преимущества:}
    \begin{itemize}
        \item Наивысшая степень абстракции и согласованности
        \item Простота семантического анализа
        \item Концептуальная чистота
        \item Устранение целых классов ошибок, связанных с примитивами
    \end{itemize}

    \item \textbf{Недостатки:}
    \begin{itemize}
        \item Высокие требования к оптимизирующему компилятору/рантайму
        \item Потенциальные сложности с низкоуровневым взаимодействием
        \item Исторически возможная неестественность представления операций как методов
    \end{itemize}

    \item \textbf{Примеры:}
    \begin{itemize}
        \item Smalltalk
        \item Ruby (и объекты, и числа имеют методы)
    \end{itemize}
\end{itemize}

\newpage