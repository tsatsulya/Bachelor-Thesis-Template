\section{Введение}
\label{sec:Chapter0} \index{Chapter0}
\onehalfspacing % Полуторный интервал

Типовая система языка программирования служит фундаментом для формального определения его спецификации, обеспечивает статический анализ программ,
поддержку оптимизаций кода и способствует улучшению его структурированности и читаемости.
Высокоуровневые языки программирования(Java, C\#, Kotlin) предоставляют разработчику мощные абстракции и безопасность кода посредством автоматического
управления памятью и объектно-ориентированных парадигм. Многие из этих языков сохранили в себе исторически сложившееся разделение типов на "примитивные" типы и ``объектные''
или ``ссылочные'', призванное потенциально улучшить производительность в некоторых случаях. Тем не менее, в то же время оно приводит к несогласованности в системе типов и
усложняет достижение полностью единообразной и интуитивной модели программирования. Примитивные типы часто лишены полезных свойств объектов, таких как наследование,
полиморфизм, вызов методов без явного упаковывания/распаковывания и использование в качестве аргумента для шаблонных типов.

В данной работе будут теоретически рассмотрены последствия устранения явной разницы между примитивными и объектными типами из высокоуровневого управляемого языка
программирования и описаны этапы и результаты реализации.

\subsection{Типовая система}

Типовая система — это формальная синтаксическая и семантическая структура, сопоставляющая типы и программные конструкции (выражения, переменные, функции) для обеспечения чётко определённого вычислительного поведения. Её основные теоретические и практические назначения:

\begin{enumerate}[label=\arabic*), leftmargin=*]
    \item \textbf{Корректность поведения программы}

    С введением типовой системы становится возможной статическая верификация соблюдения ограничений типов, не допускающая к выполнению неверно типизированные программы. Данный механизм гарантирует:

    \begin{itemize}
        \item \textit{Безопасность выполнения} — предотвращение неопределённого поведения за счёт блокировки запрещённых операций (например, некорректные обращения к памяти в управляемых средах типа JVM/CLR)
        \item \textit{Теоретическую обоснованность} — соответствие двум фундаментальным принципам типобезопасности по Райту-Феллейзену:
        \begin{enumerate}[label=\arabic*., leftmargin=*]
            \item \textbf{Прогресс}: корректно типизированная программа не может застрять в промежуточном состоянии
            \item \textbf{Сохранение}: типы остаются согласованными на всех этапах вычисления
        \end{enumerate}
    \end{itemize}

    \item \textbf{Уровень абстракции кода}

    Типовая система обеспечивает инкапсуляцию доменных инвариантов с помощью абстракций типов (абстрактные типы данных и интерфейсы) и позволяет формально специфицировать границы модулей.

    \item \textbf{Возможность оптимизаций}

    Наличие статической типизации позволяет применять оптимизации на этапе компиляции (например, специализация обобщённых типов и статическое разрешение методов) и минимизировать время исполнения в управляемых средах за счёт уменьшения количества динамических проверок типов.
\end{enumerate}

\subsection{Статическая и динамическая типизации}

\begin{enumerate}[label=\arabic*., leftmargin=*]
    \item \textbf{Статическая типизация} (Java, C\#, Kotlin):
    \begin{itemize}
        \item Валидность типа доказывается на этапе компиляции с помощью формальных суждений о принадлежности выражения к типу в данном контексте ($\Gamma \vdash e : \tau$)
        \item Гарантирует типобезопасность по Райту-Феллейзену
        \item Критично для управляемых языков программирования из-за возможности проверок безопасности памяти (например, верификатор байт-кода JVM) и эффективности Just-In-Time компиляции за счёт встраивания методов, ориентированных на конкретный тип
    \end{itemize}

    \item \textbf{Динамическая типизация} (Python, JavaScript):
    \begin{itemize}
        \item Типы функций и выражений определяются во время исполнения
        \item Нет формальной гарантии типобезопасности, но есть возможность менять поведение объектов, модулей и классов во время исполнения
    \end{itemize}
\end{enumerate}

Современные управляемые языки высокого уровня (Java, C\#) преимущественно основаны на статической типизации, расширенной возможностями динамического анализа во время выполнения. Данный компромиссный подход позволяет сочетать строгость формальной верификации с практической гибкостью разработки, но противоречие между статическими гарантиями и динамической адаптируемостью продолжает оставаться предметом активных исследований.

\newpage



\subsection{Примитивные типы}

\subsubsection{Определение}

\textbf{Примитивные типы} (далее -- примитивные типы или примитивы) являются наиболее фундаментальным типом данных в языках программирования. В отличие от объектов, они:

\begin{itemize}
    \item \textbf{Не ссылают на память}, а непосредственно являются значениями, обычно находящимися на стеке. У них отсутствуют:
    \begin{itemize}
        \item заголовок объекта (object header)
        \item таблица виртуальных методов (vtable)
        \item ссылочная идентичность (identity)
    \end{itemize}

    \item Имеют \textbf{фиксированную семантику}, определяющуюся стандартами языка (например, Java JLS §4.2, C\# ECMA-334 §8.3)

    \item \textbf{Не могут быть подтипами} или наследоваться и являются атомарными (базовыми) элементами в иерархии типов
\end{itemize}

\subsubsection{Теоретический контекст}
В теории типов примитивы являются простейшими случаями конструирования типа и не разлагаются на более простые типы. Конструирование сложных типов происходит на основе:

\begin{itemize}
    \item \textbf{Произведения} (кортежи, записи) -- (Int, Bool)
    \item \textbf{Суммы} (типы-суммы, перечисления) -- \texttt{data Maybe a = Nothing | Just a}
    \item \textbf{Функции} -- Int → Bool
    \item \textbf{Рекурсивные типы} -- \texttt{data List a = Nil | Cons a (List a)}
\end{itemize}

\subsubsection{Основные характеристики}

\begin{itemize}
    \item \textbf{Представление в памяти}
    \begin{itemize}
        {Аллокация на стеке}* (default for local variables in methods)
    \end{itemize}
    \item \textbf{Производительность на уровне процессора}
    \begin{enumerate}
        \item

        Арифметические операции с примитивами компилируются непосредственно в нативные инструкции:

        \begin{lstlisting}[language={[x86masm]Assembler}]
    ; x86 assembly for 'a + b'
    mov eax, [a]
    add eax, [b]
        \end{lstlisting}

        \item \textbf{Локализация в кэше}

        Линейная модель доступа к памяти (критично для больших вычислений)
    \end{enumerate}
\end{itemize}

\subsubsection{Примеры в высокоуровневых языках -- NEED TO BE FIXED}

\begin{table}[h]
    \centering
    \caption{Примитивные типы в различных языках программирования}
    \begin{tabular}{lccc}
        \toprule
        \textbf{Тип} & \textbf{Java} & \textbf{C\#}  \\
        \midrule
        Целые числа & \texttt{int}, \texttt{long} & \texttt{int}, \texttt{long} \\
        Числа с плавающей & \texttt{float}, \texttt{double} & \texttt{float}, \texttt{double}  \\
        Булевы значения & \texttt{boolean} & \texttt{bool} \\
        Символ & \texttt{char} & \texttt{char} \\
        \bottomrule
    \end{tabular}
\end{table}


\subsubsection{Роль примитивных типов в управляемых средах исполнения}

\begin{itemize}
    \item \textbf{Специальные байт-код инструкции}:
    \begin{itemize}
        \item В JVM: \texttt{iload}, \texttt{iadd}, \texttt{fstore} для операций с \texttt{int}, \texttt{float} и др.
        \item В CLR: аналогичные IL-команды (\texttt{ldc.i4}, \texttt{add})
    \end{itemize}

    \item \textbf{Оптимизации времени исполнения}:
    \begin{itemize}
        \item Escape-анализ: Размещение временных переменных на стеке вместо кучи
        \item Интринсики: Замена вызовов методов (например, \texttt{Math.sin()}) на нативные CPU-инструкции
    \end{itemize}
\end{itemize}
