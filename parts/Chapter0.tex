\section{Введение}
\label{sec:Chapter0} \index{Chapter0}
\onehalfspacing % Полуторный интервал

Типовая система языка программирования служит фундаментом для формального определения его спецификации, обеспечивает статический анализ программ,
поддержку оптимизаций кода и способствует улучшению его структурированности и читаемости.
Высокоуровневые языки программирования(Java, C\#, Kotlin) предоставляют разработчику мощные абстракции и безопасность кода посредством автоматического
управления памятью и объектно-ориентированных парадигм. Многие из этих языков сохранили в себе исторически сложившееся разделение типов на "примитивные" типы и ``объектные''
или ``ссылочные'', призванное потенциально улучшить производительность в некоторых случаях. Тем не менее, в то же время оно приводит к несогласованности в системе типов и
усложняет достижение полностью единообразной и интуитивной модели программирования. Примитивные типы часто лишены полезных свойств объектов, таких как наследование,
полиморфизм, вызов методов без явного упаковывания/распаковывания и использование в качестве аргумента для шаблонных типов.

В данной работе будут теоретически рассмотрены последствия устранения явной разницы между примитивными и объектными типами из высокоуровневого управляемого языка
программирования и описаны этапы и результаты реализации.

\subsection{Типовая система}

Типовая система — следуя определению Пирса\cite{pierce2002}, это формальная синтаксическая и семантическая структура, сопоставляющая типы и программные конструкции (выражения, переменные, функции) для обеспечения чётко определённого вычислительного поведения. Её основные теоретические и практические назначения:

\begin{enumerate}[label=\arabic*), leftmargin=*]
    \item \textbf{Корректность поведения программы}

    С введением типовой системы становится возможной статическая верификация соблюдения ограничений типов, не допускающая к выполнению неверно типизированные программы. Данный механизм гарантирует:

    \begin{itemize}
        \item \textit{Безопасность выполнения} — предотвращение неопределённого поведения за счёт блокировки запрещённых операций (например, некорректные обращения к памяти в управляемых средах типа JVM(Java Virtual Machine)/CLR(Common Language Runtime))
        \item \textit{Теоретическую обоснованность} — соответствие двум фундаментальным принципам типобезопасности по Райту-Феллейзену \cite{wright1994}:
        \begin{enumerate}[label=\arabic*., leftmargin=*]
            \item \textbf{Прогресс}: корректно типизированная программа не может застрять в промежуточном состоянии
            \item \textbf{Сохранение}: типы остаются согласованными на всех этапах вычисления
        \end{enumerate}
    \end{itemize}

    \item \textbf{Уровень абстракции кода}

    Типовая система обеспечивает инкапсуляцию доменных инвариантов с помощью абстракций типов (абстрактные типы данных и интерфейсы) и позволяет формально специфицировать границы модулей.

    \item \textbf{Возможность оптимизаций}

    Наличие статической типизации позволяет применять оптимизации на этапе компиляции (например, специализация шаблонных типов и статическое разрешение методов) и минимизировать время исполнения в управляемых средах за счёт уменьшения количества динамических проверок типов.
\end{enumerate}

\subsection{Статическая и динамическая типизации}

\begin{enumerate}[label=\arabic*., leftmargin=*]
    \item \textbf{Статическая типизация} (Java, C\#, Kotlin):
    \begin{itemize}
        \item Валидность типа доказывается на этапе компиляции с помощью формальных суждений о принадлежности выражения к типу в данном контексте ($\Gamma \vdash e : \tau$)
        \item Гарантирует типобезопасность по Райту-Феллейзену
        \item Критично для управляемых языков программирования из-за возможности проверок безопасности памяти (например, верификатор байт-кода JVM) и эффективности Just-In-Time компиляции за счёт встраивания методов, ориентированных на конкретный тип
    \end{itemize}

    \item \textbf{Динамическая типизация} (Python, JavaScript):
    \begin{itemize}
        \item Типы функций и выражений определяются во время исполнения
        \item Нет формальной гарантии типобезопасности, но есть возможность менять поведение объектов, модулей и классов во время исполнения
    \end{itemize}
\end{enumerate}

Современные управляемые языки высокого уровня (Java, C\#) преимущественно основаны на статической типизации, расширенной возможностями динамического анализа во время выполнения. Данный компромиссный подход позволяет сочетать строгость формальной верификации с практической гибкостью разработки, но противоречие между статическими гарантиями и динамической адаптируемостью продолжает оставаться предметом активных исследований.

Исторически и архитектурно, многие языки разделяют типы на две категории:
\textbf{Примитивные типы} (далее -- примитивные типы или примитивы) Представляют собой базовые значения (например, целые числа, числа с плавающей точкой, булевы значения, символы).
\textbf{Ссылочные типы} (далее - ссылочные типы, объектные типы)Представляют собой экземпляры классов, которые хранятся в куче (heap) и управляются сборщиком мусора. Они наследуются от базового класса и обладают методами, полями и другими объектно-ориентированными свойствами.
\newpage


\subsection{Примитивные типы}

\textbf{Примитивные типы} являются наиболее фундаментальным типом данных в языках программирования. В отличие от объектных типов, они:

\begin{itemize}
    \item \textbf{Не ссылают на память}, а непосредственно являются значениями. У них отсутствуют:
    \begin{itemize}
        \item заголовок объекта (object header)
        \item таблица виртуальных методов (vtable)
        \item ссылочная идентичность (identity)
    \end{itemize}
    \item Имеют \textbf{фиксированную семантику}, определяющуюся стандартами языка (например, Java JLS §4.2 \cite{java_spec}, C\# ECMA-334 §8.3 \cite{csharp_spec})

    \item \textbf{Не могут быть подтипами} или наследоваться и являются атомарными (базовыми) элементами в иерархии типов
\end{itemize}

\subsubsection{Роль в конструировании типов}
В теории типов примитивы являются простейшими случаями конструирования типа и не разлагаются на более простые типы. Конструирование сложных типов происходит на основе:

\begin{itemize}
    \item \textbf{Произведения} (кортежи, записи) -- (Int, Bool)
    \item \textbf{Суммы} (типы-суммы, перечисления) -- \texttt{data Maybe a = Nothing | Just a}
    \item \textbf{Функции} -- Int → Bool
    \item \textbf{Рекурсивные типы} -- \texttt{data List a = Nil | Cons a (List a)}
\end{itemize}

\subsubsection{Основные характеристики}

\begin{itemize}
    \item \textbf{Представление в памяти}
    \begin{itemize}
        {Аллокация на стеке} (за исключением глобальных переменных)
    \end{itemize}
    \item \textbf{Производительность на уровне процессора}
    \begin{enumerate}
        \item

        Арифметические операции с примитивами компилируются непосредственно в нативные инструкции:

        \begin{lstlisting}[language={[x86masm]Assembler}]
    ; x86 assembly for 'a + b'
    mov eax, [a]
    add eax, [b]\end{lstlisting}

        \item \textbf{Локализация в кэше}

        Линейная модель доступа к памяти (критично для больших вычислений)
    \end{enumerate}
\end{itemize}

\subsubsection{Примеры в высокоуровневых языках}

\begin{table}[h]
    \centering
    \title{Примитивные типы в различных языках программирования}
    \begin{tabular}{lccc}
        \toprule
        \textbf{Тип} & \textbf{Java} & \textbf{C\#}  \\
        \midrule
        Целые числа & \texttt{int}, \texttt{long} & \texttt{int}, \texttt{long} \\
        Числа с плавающей & \texttt{float}, \texttt{double} & \texttt{float}, \texttt{double}  \\
        Булевы значения & \texttt{boolean} & \texttt{bool} \\
        Символ & \texttt{char} & \texttt{char} \\
        \bottomrule
    \end{tabular}
\end{table}

\newpage

\subsection{Роль примитивных типов в управляемых средах исполнения}

\textbf{ Управляемая среда исполнения (Managed Execution Environment)} — это программный компонент или слой, который обеспечивает выполнение программного кода в контролируемой,
безопасной и абстрагированной от низкоуровневых деталей среде. Она действует как посредник между скомпилированным (или интерпретируемым) кодом приложения и базовой операционной
системой или аппаратным обеспечением.

\subsubsection{Основные функции и компоненты среды исполнения}

\begin{description}

    \item[Виртуальная Машина (ВМ) / Интерпретатор:]
    Ядро среды исполнения, которое выполняет промежуточный код (байт-код или Common Intermediate Language – CIL). Примеры включают Java Virtual Machine и Common Language Runtime для .NET. ВМ изолирует исполняемый код от конкретной аппаратной архитектуры и операционной системы.
    \item[JIT-компиляция (Just-In-Time Compilation):]
    Для повышения производительности многие ВМ используют JIT-компиляторы. Они динамически переводят промежуточный код в машинный код непосредственно перед его выполнением. JIT-компиляторы могут применять оптимизации на основе профилирования времени выполнения, что часто позволяет достичь производительности, сопоставимой с нативно скомпилированным кодом.
    \item[Загрузчики Классов/Сборок:]
    Эти компоненты отвечают за динамическую загрузку программных модулей (классов, библиотек, сборок) по мере их необходимости во время выполнения программы. Они также управляют разрешением зависимостей и проверкой целостности загружаемых компонентов.
    \item[Система Управления Потоками:]
    Среда исполнения предоставляет интерфейс и механизмы для создания, управления и синхронизации потоков выполнения, обеспечивая эффективную поддержку параллельных вычислений.
    \item[Система Безопасности:]
    Высокоуровневые языки программирования часто включают встроенные модели безопасности (например, песочницы), которые контролируют доступ исполняемого кода к системным ресурсам, таким как файловая система, сеть или другие процессы, что особенно важно для кода, загружаемого из недоверенных источников.
    \item[Встроенные Сервисы:]
    К ним относятся механизмы обработки исключений, рефлексия (возможность интроспекции и модификации структуры кода во время выполнения), сериализация, а также поддержка взаимодействия с нативным кодом (Native Interface).
\end{description}

\subsubsection{Примитивные типы в управляемых средах исполнения}

Примитивные типы данных в контексте управляемых сред исполнения (таких как .NET CLR и Java VM) обладают характеристиками и принципами работы,
отличающимися от неуправляемых сред, например, реализованных на языках C/C++.


\subsubsection*{Абстракция и безопасность}
Управляемые среды исполнения предоставляют уровень абстракции, скрывающий детали низкоуровневого представления примитивных типов данных в памяти. Это обеспечивает платформонезависимость и переносимость программного обеспечения.
Кроме того, такие среды реализуют строгую проверку типов как на этапе компиляции, так и во время исполнения, что служит профилактикой ошибочного использования типов данных и возникновения уязвимостей, связанных с выделением памяти и выходом за границы допустимых областей.

\subsubsection*{Гарантированная инициализация}
В отличие от неуправляемых сред, где переменные могут содержать неинициализированные значения, управляемые среды гарантируют автоматическую инициализацию переменных
примитивных типов значениями по умолчанию. Это исключает возможность непредсказуемого поведения, связанного с использованием мусорных значений памяти.

\subsubsection*{Сборка мусора}
В управляемых средах примитивные типы данных, как правило, не подлежат сборке мусора напрямую. Обычно они размещаются в стеке либо, если выступают в роли компонентов объектов, внутри кучи. Освобождение памяти, занятой объектами (соответственно, и их полями-примитивами),
происходит посредством встроенного механизма сборки мусора, что снимает с разработчика необходимость вручную управлять памятью.

\subsubsection*{Cтандартное поведение}
Управляемые среды исполнения гарантируют предсказуемое и стандартизированное поведение всех операций с примитивными типами данных, в том числе арифметических.
Данная особенность повышает надежность и упрощает переносимость программ между различными аппаратными и программными платформами.

\subsubsection*{Механизм упаковки и распаковки}
Управляемые среды поддерживают механизм упаковки (\textit{от англ. boxing, далее - боксинг, упаковка}) и распаковки (\textit{от англ. unboxing, далее - распаковка, анбоксинг}), позволяющий преобразовывать значения примитивных типов в объекты и обратно.
Это особенно актуально при взаимодействии с универсальными коллекциями и другими структурами, требующими объектного представления данных.
Например, в среде C\# значение типа \verb|int| может быть преобразовано в объект (\textit{boxing}) и обратно (\textit{unboxing}).

\subsubsection*{Примеры реализации}
\begin{itemize}
    \item \textbf{.NET (например, на C\#)}: Примитивные типы (такие как \verb|System.Int32|) реализованы в виде структур и обеспечивают предсказуемое поведение за счёт встроенных механизмов среды.
    \item \textbf{Java}: Примитивные типы (\verb|int|, \verb|boolean|, \verb|char|) имеют фиксированные размеры и поведение. Для поддержки упаковки и распаковки используются соответствующие классы-обёртки (\verb|Integer|, \verb|Boolean|, \verb|Character|).
\end{itemize}


\subsection{Несогласованность примитивных типов в управляемых языках программирования}

В большинстве управляемых языков программирования (таких как Java, C\#, Python) существует проблема несогласованности обработки примитивных типов данных и объектных типов в рамках единой системы типов. Эта асимметрия оказывает существенное влияние на архитектуру языка, его производительность и способность к применению принципов объектно-ориентированного программирования.

\subsubsection*{Отсутствие единообразия в системе типов}
Одной из ключевых проблем является отсутствие унифицированного представления примитивных и объектных типов в системе типов управляемого языка.
Это бинарное разделение приводит к концептуальной и синтаксической асимметрии. Например, примитивные типы не могут быть \texttt{null} (без дополнительных оберток), не поддерживают полиморфизм и не могут использоваться там, где требуется экземпляр класса \texttt{Object} (например, в универсальных коллекциях) без явного или неявного преобразования.

\subsubsection*{Ограничения в Объектно-Ориентированных Возможностях}
Несогласованность примитивных типов создает существенные ограничения для применения объектно-ориентированных парадигм: инкапсуляция, наследование и полиморфизм.

\begin{itemize}
    \item \textbf{Отсутствие наследования и полиморфизма:} Примитивные типы не могут наследоваться, и к ним не применимы механизмы полиморфизма через интерфейсы или абстрактные классы. Это означает, что функции, ожидающие экземпляр базового класса или интерфейса, не могут напрямую работать с примитивными значениями.

    \item \textbf{Проблемы с коллекциями и шаблонных типами:} Для включения примитивных значений в объектные коллекции (например, \texttt{ArrayList<Object>} в Java или \texttt{List<object>} в C\#) требуется механизм автоматической или явной упаковки (boxing) в соответствующие объектные обертки (например, \texttt{Integer} для \texttt{int}, \texttt{Double} для \texttt{double}). Это не только нарушает прозрачность и чистоту кода, но и может приводить к неожиданным побочным эффектам или ошибкам типизации, если разработчик не учитывает процесс упаковки/распаковки.

    \item \textbf{Нарушение унифицированного доступа:} Объектно-ориентированный дизайн стремится к унифицированному доступу к данным и поведению через методы. Примитивные типы не обладают методами, так что разработчик должен использовать процедурные подходы или статические вспомогательные классы для выполнения операций над ними.
\end{itemize}

\subsubsection*{Производительность и накладные расходы}
\label{sec:performance}

Примитивные типы, как было описано выше, позволяют достичь высокой производительности из-за их прямой аллокации в стеке или регистрах. Тем не менее, их несогласованность с объектной системой может приводить к значительным накладным расходам \cite{chen2019}. Оптимизации работы с типами в JVM подробно рассмотрены в \cite{goetz2006}

\begin{itemize}[leftmargin=*,nosep]
    \item \textbf{Операции упаковки и распаковки (Boxing/Unboxing):} Эти операции, интегрирующие примитивы в объектную иерархию, влекут за собой:
    \begin{itemize}
        \item \textbf{Аллокацию памяти в куче:} Для каждого упакованного примитивного значения создается новый объект в куче, что увеличивает потребление памяти.
        \item \textbf{Дополнительные циклы процессора:} Создание и инициализация объектов-оберток, а также последующее их удаление сборщиком мусора, требуют процессорного времени.
        \item \textbf{Увеличение нагрузки на сборщик мусора:} Большое количество короткоживущих объектов-оберток создает дополнительную работу для сборщика мусора, потенциально приводя к задержкам в работе приложения.
    \end{itemize}

    \item \textbf{Избыточные преобразования типов:} В сложных системах, где примитивы часто передаются между функциями, ожидающими объектные типы, и наоборот, могут возникать множественные операции упаковки и распаковки, что негативно сказывается на общей производительности системы.
\end{itemize}

\subsubsection*{Влияние на проектирование языка и его особенности}

Асимметрия между примитивными и объектными типами оказывает глубокое влияние на архитектуру и проектирование самих управляемых языков, усложняя их реализацию и использование.

\begin{itemize}[leftmargin=*,nosep]
    \item \textbf{Сложность дизайна и реализации компилятора/рантайма:} Разработчикам языков приходится вводить специальные правила и исключения для обработки примитивных типов, которые не соответствуют общей объектной модели. Это увеличивает сложность компилятора и среды исполнения, требуя специализированных путей кода для различных типов.

    \item \textbf{Ограничения в расширяемости:} Механизмы расширения языка, такие как операторная перегрузка или метапрограммирование, могут быть ограничены или усложнены из-за необходимости учитывать различия между примитивами и объектами.

    \item \textbf{Влияние на ключевые функции языка:}
    \begin{itemize}
        \item \textbf{Рефлексия:} Механизмы рефлексии(интроспекции и модификации кода во время выполнения) должны предоставлять отдельные интерфейсы для примитивных и объектных типов или вводить специальные обертки для работы с примитивами.
        \item \textbf{Сериализация:} Унифицированная сериализация данных становится более сложной, поскольку необходимо обрабатывать как объекты, так и примитивные значения.
        \item \textbf{Типы, допускающие зачение null:} Введение безопасных nullable-типов (например, \texttt{int?} в C\#) часто требует дополнительной работы для примитивов, в то время как объектные типы по умолчанию могут быть \texttt{null}.
    \end{itemize}

    \item \textbf{Дополнительная нагрузка на разработчика:} Разработчики, использующие управляемые языки, вынуждены постоянно учитывать различия между примитивами и объектами и помнить, когда и где следует использовать примитив, а когда — его объектную обертку, добавляет сложности в процесс разработки.
\end{itemize}
